"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var xml2js = require("xml-js");
function typeNameFromType(type) {
    return type ? type.split('.').pop() : null;
}
function getEntityBaseTypes(entityType, entityTypes) {
    var baseTypes = [];
    var _loop_1 = function () {
        var baseTypeName = typeNameFromType(entityType['$']['BaseType']);
        entityType = entityTypes.find(function (entity) { return entity['$']['Name'] == baseTypeName; });
        if (entityType) {
            baseTypes.push(entityType);
        }
    };
    while (entityType) {
        _loop_1();
    }
    return baseTypes;
}
function parseEntitySets(namespace, entityContainer, entityTypes, annotations) {
    return entityContainer['EntitySet'].map(function (entitySet) {
        var type = typeNameFromType(entitySet['$']['EntityType']);
        var entityType = entityTypes.find(function (entity) { return entity['$']['Name'] == type; });
        if (entityType) {
            return parseEntitySet(namespace, entitySet, entityType, entityTypes, annotations);
        }
    }).filter(function (entitySet) { return !!entitySet; });
}
function parseEntitySet(namespace, entitySet, entityType, entityTypes, annotations) {
    return {
        namespace: namespace,
        name: entitySet['$']['Name'],
        entityType: parseEntityType(entityType, entityTypes, namespace),
        annotations: parseEntityTypeAnnotations(namespace, entityType, entityTypes, annotations)
    };
}
function parseEntityPaths(namespace, entityType, entityTypes) {
    var paths = [];
    if (entityType['NavigationProperty']) {
        entityType['NavigationProperty'].forEach(function (p) {
            if (p['$']['ContainsTarget']) {
                paths.push({
                    name: p['$']['Name'],
                    type: p['$']['Type'],
                });
            }
        });
    }
    return paths;
}
function parseEntityTypeAnnotations(namespace, entityType, entityTypes, annotations) {
    var allTypes = [entityType].concat(getEntityBaseTypes(entityType, entityTypes));
    var typeAnnotations = [];
    if (annotations) {
        annotations.forEach(function (a) {
            allTypes.forEach(function (t) {
                if (a.target == namespace + "." + t['$']['Name']) {
                    a.terms.forEach(function (term) {
                        if (typeAnnotations.indexOf(term) == -1) {
                            typeAnnotations.push(term);
                        }
                    });
                }
            });
        });
    }
    return typeAnnotations;
}
function flatten(a) {
    return Array.isArray(a) ? [].concat.apply([], a.map(flatten)) : a;
}
function parseEntityType(entityType, entityTypes, namespace) {
    var entityBaseTypes = getEntityBaseTypes(entityType, entityTypes);
    var entityBaseProperties = flatten(entityBaseTypes.map(function (t) { return (t['Property'] || []).map(parseProperty); }));
    var result = {
        name: entityType['$']['Name'],
        abstract: entityType['$']['Abstract'],
        properties: entityBaseProperties.concat((entityType['Property'] || []).map(parseProperty)),
        paths: parseEntityPaths(namespace, entityType, entityTypes),
        namespace: namespace
    };
    var baseTypeWithKey = entityBaseTypes.find(function (t) { return t['Key']; });
    var keys = entityType['Key'] || (baseTypeWithKey && baseTypeWithKey['Key']);
    if (keys && keys.length > 0) {
        result.key = parseKey(keys[0], result.properties);
    }
    var navigationProperties = entityType['NavigationProperty'];
    if (navigationProperties && navigationProperties.length > 0) {
        navigationProperties.forEach(function (property) {
            var type = property['$']['Type'];
            if (type) { // OData V4 only
                var ref = "#/definitions/" + type.split(/[()]/)[1];
                var name = property['$']['Name'];
                if (type.startsWith('Collection(')) {
                    result.properties.push({
                        name: name,
                        type: 'array',
                        items: {
                            $ref: ref
                        },
                        wrapValueInQuotesInUrls: true
                    });
                }
                else {
                    var prop = {
                        name: name,
                        $ref: "#/definitions/" + type,
                        wrapValueInQuotesInUrls: true
                    };
                    var refConstraint = property['ReferentialConstraint'];
                    var constraints = refConstraint ? refConstraint.map(function (c) {
                        return {
                            property: c['$']['Property'],
                            refProperty: c['$']['ReferencedProperty']
                        };
                    }) : [];
                    prop['x-ref'] = {
                        name: name,
                        partner: property['$']['Partner'],
                        constraints: constraints
                    };
                    result.properties.push(prop);
                }
            }
        });
    }
    return result;
}
function parseKey(key, properties) {
    var refs = key['PropertyRef'].map(function (propertyRef) { return propertyRef['$']['Name']; });
    return properties.filter(function (property) { return refs.includes(property.name); });
}
function parseProperty(property) {
    var type = property['$']['Type'];
    var dontWrapValueInQuotesInUrlsTypes = ['Edm.Int16', 'Edm.Int32', 'Edm.Int64', 'Edm.Double', 'Edm.Single', 'Edm.Decimal', 'Edm.Guid'];
    var wrapValueInQuotesInUrls = !dontWrapValueInQuotesInUrlsTypes.includes(type);
    var result = {
        required: property['$']['Nullable'] == 'false',
        name: property['$']['Name'],
        wrapValueInQuotesInUrls: wrapValueInQuotesInUrls
    };
    if (type.startsWith('Collection(')) {
        var objectType = type.match(/^Collection\((.*)\)$/)[1];
        result.type = 'array';
        if (objectType.startsWith('Edm.')) {
            result.items = {
                type: objectType
            };
        }
        else {
            result.items = {
                $ref: "#/definitions/" + objectType
            };
        }
    }
    else {
        result.type = type;
    }
    return result;
}
function parseActions(actions) {
    return actions && actions.length ? actions.map(function (action) {
        return {
            name: action['$']['Name'],
            isBound: action['$']['IsBound'],
            entitySetPath: action['$']['EntitySetPath'],
            returnType: parseReturnTypes(action['ReturnType']),
            parameters: parseActionAndFunctionParameters(action['Parameter']),
        };
    }) : [];
}
function parseFunctions(functions) {
    return functions && functions.length ? functions.map(function (func) {
        return {
            name: func['$']['Name'],
            isBound: func['$']['IsBound'],
            isComposable: func['$']['IsComposable'],
            entitySetPath: func['$']['EntitySetPath'],
            returnType: parseReturnTypes(func['ReturnType']),
            parameters: parseActionAndFunctionParameters(func['Parameter']),
        };
    }) : [];
}
function parseReturnTypes(returnType) {
    return returnType && returnType[0] ? {
        type: returnType[0]['$']['Type'],
        nullable: !(returnType[0]['$']['Nullable'] == 'false'),
    } : null;
}
function parseActionAndFunctionParameters(parameters) {
    return parameters && parameters.length ? parameters.map(function (parameter) {
        return {
            name: parameter['$']['Name'],
            type: parameter['$']['Type'],
            nullable: !(parameter['$']['Nullable'] == 'false'),
        };
    }) : [];
}
function parseComplexTypes(complexTypes, schemas) {
    return complexTypes && complexTypes.length ? complexTypes.map(function (t) {
        var schema = schemas.find(function (s) { return s['ComplexType'].find(function (ct) { return ct == t; }); });
        return {
            name: t['$']['Name'],
            properties: (t['Property'] || []).map(parseProperty),
            namespace: schema ? schema['$']['Namespace'] : null
        };
    }) : [];
}
function parseEnumTypes(enumTypes, schemas) {
    return enumTypes && enumTypes.length ? enumTypes.map(function (t) {
        var schema = schemas.find(function (s) { return s['EnumType'].find(function (ct) { return ct == t; }); });
        return {
            name: t['$']['Name'],
            memberNames: (t['Member'] || []).map(function (m) { return m['$']['Name']; }),
            namespace: schema ? schema['$']['Namespace'] : null
        };
    }) : [];
}
function parseAnnotations(annotations) {
    return annotations && annotations.length ? annotations.map(function (t) {
        return {
            target: t['$']['Target'],
            terms: (t['Annotation'] || []).map(function (a) { return a['$']['Term']; })
        };
    }) : [];
}
function parseSingletons(singletons, entitySets) {
    return singletons && singletons.length ? singletons.map(function (s) {
        var properties = [];
        (s['NavigationPropertyBinding'] || []).forEach(function (n) {
            var entitySet = entitySets.find(function (es) { return es.name == n['$']['Target']; });
            if (entitySet) {
                var path = n['$']['Path'];
                if (path) {
                    properties.push({
                        name: path.split('/').pop(),
                        type: path.indexOf('/') != -1 ? entitySet.namespace + "." + entitySet.entityType.name :
                            "Collection(" + entitySet.namespace + "." + entitySet.entityType.name + ")"
                    });
                }
            }
        });
        return {
            name: s['$']['Name'],
            type: s['$']['Type'],
            properties: properties
        };
    }) : [];
}
function parseEntityTypes(entityTypes, schemas) {
    return entityTypes.map(function (et) {
        var schema = schemas.find(function (s) { return s['EntityType'].find(function (t) { return t == et; }); });
        return parseEntityType(et, entityTypes, schema ? schema['$']['Namespace'] : null);
    });
}
function parse(xml) {
    return new Promise(function (resolve, reject) {
        var metadata = xml2js.xml2js(xml, { compact: true, trim: true, alwaysArray: true, attributesKey: '$' });
        var version = metadata['edmx:Edmx'][0]['$'].Version;
        var dataServices = metadata['edmx:Edmx'][0]['edmx:DataServices'][0];
        var schemas = dataServices['Schema'];
        var entityContainerSchema = schemas.find(function (schema) { return schema['EntityContainer']; });
        if (!entityContainerSchema) {
            reject(new Error('Cannot find EntityContainer element.'));
        }
        var entityContainer = entityContainerSchema['EntityContainer'][0];
        var defaultNamespace = entityContainerSchema['$']['Namespace'];
        var actions = parseActions(entityContainerSchema['Action']);
        var functions = parseFunctions(entityContainerSchema['Function']);
        var annotations = parseAnnotations(entityContainerSchema['Annotations']);
        var entitySets = [];
        var allEntityTypes = [];
        var allComplexTypes = [];
        var allEnumTypes = [];
        schemas.forEach(function (schema) {
            if (schema['EntityType']) {
                var namespace = schema['$']['Namespace'];
                var schemaEntityTypes = schema['EntityType'];
                allEntityTypes.push.apply(allEntityTypes, schemaEntityTypes);
                entitySets.push.apply(entitySets, parseEntitySets(namespace, entityContainer, schemaEntityTypes, annotations));
            }
            if (schema['ComplexType']) {
                var schemaComplexTypes = schema['ComplexType'];
                allComplexTypes.push.apply(allComplexTypes, schemaComplexTypes);
            }
            if (schema['EnumType']) {
                var schemaEnumTypes = schema['EnumType'];
                allEnumTypes.push.apply(allEnumTypes, schemaEnumTypes);
            }
        });
        var complexTypes = parseComplexTypes(entityContainerSchema['ComplexType'], schemas);
        var singletons = parseSingletons(entityContainer['Singleton'], entitySets);
        var entityTypes = parseEntityTypes(allEntityTypes, schemas);
        var enumTypes = parseEnumTypes(allEnumTypes, schemas);
        resolve({ entitySets: entitySets, version: version, complexTypes: complexTypes, singletons: singletons, actions: actions, functions: functions, defaultNamespace: defaultNamespace, entityTypes: entityTypes, enumTypes: enumTypes });
    });
}
exports.default = parse;
//# sourceMappingURL=parse.js.map